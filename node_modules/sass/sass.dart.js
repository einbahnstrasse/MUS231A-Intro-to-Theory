// make sure to keep this as 'var'
// we don't want block scoping

var dartNodePreambleSelf = typeof global !== "undefined" ? global : window;

var self = Object.create(dartNodePreambleSelf);

self.scheduleImmediate = typeof setImmediate !== "undefined"
    ? function (cb) {
        setImmediate(cb);
      }
    : function(cb) {
        setTimeout(cb, 0);
      };

// CommonJS globals.
self.exports = exports;

// Node.js specific exports, check to see if they exist & or polyfilled

if (typeof process !== "undefined") {
  self.process = process;
}

if (typeof __dirname !== "undefined") {
  self.__dirname = __dirname;
}

if (typeof __filename !== "undefined") {
  self.__filename = __filename;
}

if (typeof Buffer !== "undefined") {
  self.Buffer = Buffer;
}

// if we're running in a browser, Dart supports most of this out of box
// make sure we only run these in Node.js environment

var dartNodeIsActuallyNode = !dartNodePreambleSelf.window

try {
  // Check if we're in a Web Worker instead.
  if ("undefined" !== typeof WorkerGlobalScope && dartNodePreambleSelf instanceof WorkerGlobalScope) {
    dartNodeIsActuallyNode = false;
  }

  // Check if we're in Electron, with Node.js integration, and override if true.
  if ("undefined" !== typeof process && process.versions && process.versions.hasOwnProperty('electron') && process.versions.hasOwnProperty('node')) {
    dartNodeIsActuallyNode = true;
  }
} catch(e) {}

if (dartNodeIsActuallyNode) {
  // This line is to:
  // 1) Prevent Webpack from bundling.
  // 2) In Webpack on Node.js, make sure we're using the native Node.js require, which is available via __non_webpack_require__
  // https://github.com/mbullington/node_preamble.dart/issues/18#issuecomment-527305561
  var url = ("undefined" !== typeof __webpack_require__ ? __non_webpack_require__ : require)("url");

  // Setting `self.location=` in Electron throws a `TypeError`, so we define it
  // as a property instead to be safe.
  Object.defineProperty(self, "location", {
    value: {
      get href() {
        if (url.pathToFileURL) {
          return url.pathToFileURL(process.cwd()).href + "/";
        } else {
          // This isn't really a correct transformation, but it's the best we have
          // for versions of Node <10.12.0 which introduced `url.pathToFileURL()`.
          // For example, it will fail for paths that contain characters that need
          // to be escaped in URLs.
          return "file://" + (function() {
            var cwd = process.cwd();
            if (process.platform != "win32") return cwd;
            return "/" + cwd.replace(/\\/g, "/");
          })() + "/"
        }
      }
    }
  });

  (function() {
    function computeCurrentScript() {
      try {
        throw new Error();
      } catch(e) {
        var stack = e.stack;
        var re = new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "mg");
        var lastMatch = null;
        do {
          var match = re.exec(stack);
          if (match != null) lastMatch = match;
        } while (match != null);
        return lastMatch[1];
      }
    }

    // Setting `self.document=` isn't known to throw an error anywhere like
    // `self.location=` does on Electron, but it's better to be future-proof
    // just in case..
    var cachedCurrentScript = null;
    Object.defineProperty(self, "document", {
      value: {
        get currentScript() {
          if (cachedCurrentScript == null) {
            cachedCurrentScript = {src: computeCurrentScript()};
          }
          return cachedCurrentScript;
        }
      }
    });
  })();

  self.dartDeferredLibraryLoader = function(uri, successCallback, errorCallback) {
    try {
     load(uri);
      successCallback();
    } catch (error) {
      errorCallback(error);
    }
  };
}

self.chokidar = require("chokidar");
self.readline = require("readline");
self.fs = require("fs");
// Generated by dart2js (NullSafetyMode.sound, trust primitives, omit checks, lax runtime type, no-legacy-javascript), the Dart to JavaScript compiler version: 2.14.2.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback, loadId):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error. The loadId argument is the deferred import that resulted in
//    this uri being loaded.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  function mixinProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!to.hasOwnProperty(key))
        to[key] = from[key];
    }
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function setFunctionNamesIfNecessary(holders) {
    function t() {
    }
    ;
    if (typeof t.name == "string")
      return;
    for (var i = 0; i < holders.length; i++) {
      var holder = holders[i];
      var keys = Object.keys(holder);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        var f = holder[key];
        if (typeof f == "function")
          f.name = key;
      }
    }
  }
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        cls.prototype.__proto__ = sup.prototype;
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++)
      inherit(classes[i], sup);
  }
  function mixin(cls, mixin) {
    mixinProperties(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazyOld(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      holder[getterName] = function() {
        H.throwCyclicInit(name);
      };
      var result;
      var sentinelInProgress = initializer;
      try {
        if (holder[name] === uninitializedSentinel) {
          result = holder[name] = sentinelInProgress;
          result = holder[name] = initializer();
        } else
          result = holder[name];
      } finally {
        if (result === sentinelInProgress)
          holder[name] = null;
        holder[getterName] = function() {
          return this[name];
        };
      }
      return result;
    };
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel)
        holder[name] = initializer();
      holder[getterName] = function() {
        return this[name];
      };
      return holder[name];
    };
  }
  function lazyFinal(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        var value = initializer();
        if (holder[name] !== uninitializedSentinel)
          H.throwLateFieldADI(name);
        holder[name] = value;
      }
      holder[getterName] = function() {
        return this[name];
      };
      return holder[name];
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i)
      convertToFastObject(arrayOfObjects[i]);
  }
  var functionCounter = 0;
  function instanceTearOffGetter(isIntercepted, parameters) {
    var name = parameters.fs[0];
    if (isIntercepted)
      return new Function("parameters, createTearOffClass, cache", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (cache === null) cache = createTearOffClass(parameters);" + "return new cache(receiver, this);" + "}")(parameters, H.closureFromTearOff, null);
    else
      return new Function("parameters, createTearOffClass, cache", "return function tearOff_" + name + functionCounter++ + "() {" + "if (cache === null) cache = createTearOffClass(parameters);" + "return new cache(this, null);" + "}")(parameters, H.closureFromTearOff, null);
  }
  function staticTearOffGetter(parameters) {
    var cache = null;
    return function() {
      if (cache === null)
        cache = H.closureFromTearOff(parameters).prototype;
      return cache;
    };
  }
  var typesOffset = 0;
  function tearOffParameters(container, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    if (typeof funType == "number")
      funType += typesOffset;
    return {co: container, iS: isStatic, iI: isIntercepted, rC: requiredParameterCount, dV: optionalParameterDefaultValues, cs: callNames, fs: funsOrNames, fT: funType, aI: applyIndex || 0, nDA: needsDirectAccess};
  }
  function installStaticTearOff(holder, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var parameters = tearOffParameters(holder, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, false);
    var getterFunction = staticTearOffGetter(parameters);
    holder[getterName] = getterFunction;
  }
  function installInstanceTearOff(prototype, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    isIntercepted = !!isIntercepted;
    var parameters = tearOffParameters(prototype, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, !!needsDirectAccess);
    var getterFunction = instanceTearOffGetter(isIntercepted, parameters);
    prototype[getterName] = getterFunction;
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex, false);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixin, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, lazyFinal: lazyFinal, lazyOld: lazyOld, updateHolder: updateHolder, convertToFastObject: convertToFastObject, setFunctionNamesIfNecessary: setFunctionNamesIfNecessary, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  var A = {MapExpression: function MapExpression(t0, t1) {
      this.pairs = t0;
      this.span = t1;
    }, MapExpression_toString_closure: function MapExpression_toString_closure() {
    }, IncludeRule: function IncludeRule(t0, t1, t2, t3, t4) {
      var _ = this;
      _.namespace = t0;
      _.name = t1;
      _.$arguments = t2;
      _.content = t3;
      _.span = t4;
    }, Configuration: function Configuration(t0) {
      this._values = t0;
    }, Configuration_toString_closure: function Configuration_toString_closure() {
    }, ExplicitConfiguration: function ExplicitConfiguration(t0, t1) {
      this.nodeWithSpan = t0;
      this._values = t1;
    },
    watch(options, graph) {
      return A.watch$body(options, graph);
    },
    watch$body(options, graph) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, t1, t2, t3, t4, t5, t6, dirWatcher, watcher;
      var $async$watch = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              options._ensureSources$0();
              t1 = type$.String;
              t2 = options.get$_sourceDirectoriesToDestinations().cast$2$0(0, t1, t1);
              t2 = P.List_List$of(t2.get$keys(t2), true, t1);
              for (options._ensureSources$0(), t3 = options._sourcesToDestinations.cast$2$0(0, t1, t1), t3 = J.get$iterator$ax(t3.get$keys(t3)); t3.moveNext$0();) {
                t4 = t3.get$current(t3);
                t2.push($.$get$context().dirname$1(t4));
              }
              t3 = options._options;
              C.JSArray_methods.addAll$1(t2, type$.List_String._as(t3.$index(0, "load-path")));
              t4 = H._asBool(t3.$index(0, "poll"));
              t5 = type$.Stream_WatchEvent;
              t6 = K.PathMap__create(null, t5);
              t5 = new L.StreamGroup(C._StreamGroupState_dormant, P.LinkedHashMap_LinkedHashMap$_empty(t5, type$.nullable_StreamSubscription_WatchEvent), type$.StreamGroup_WatchEvent);
              t5.__StreamGroup__controller = P.StreamController_StreamController(t5.get$_onCancel(), t5.get$_onListen(), t5.get$_onPause(), t5.get$_onResume(), true, type$.WatchEvent);
              dirWatcher = new U.MultiDirWatcher(new K.PathMap(t6, type$.PathMap_Stream_WatchEvent), t5, t4);
              $async$goto = 3;
              return P._asyncAwait(P.Future_wait(new H.MappedListIterable(t2, new A.watch_closure(dirWatcher), H._arrayInstanceType(t2)._eval$1("MappedListIterable<1,Future<~>>")), type$.void), $async$watch);
            case 3:
              // returning from await.
              watcher = new A._Watcher(options, graph);
              options._ensureSources$0(), t1 = options._sourcesToDestinations.cast$2$0(0, t1, t1), t1 = t1.get$entries(t1), t1 = t1.get$iterator(t1);
            case 4:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 5;
                break;
              }
              t2 = t1.get$current(t1);
              t4 = $.$get$context();
              t5 = t4.absolute$7(".", null, null, null, null, null, null);
              t6 = t2.key;
              graph.addCanonical$4$recanonicalize(new F.FilesystemImporter(t5), t4.toUri$1(J.$eq$(J.get$platform$x(self.process), "win32") || J.$eq$(J.get$platform$x(self.process), "darwin") ? F._realCasePath(t4.absolute$7(t4.normalize$1(t6), null, null, null, null, null, null)) : t4.canonicalize$1(t6)), t4.toUri$1(t6), false);
              $async$goto = 6;
              return P._asyncAwait(watcher.compile$3$ifModified(t6, t2.value, true), $async$watch);
            case 6:
              // returning from await.
              if (!$async$result && H._asBool(t3.$index(0, "stop-on-error"))) {
                t1 = dirWatcher._group.__StreamGroup__controller;
                if (t1 == null)
                  t1 = H.throwExpression(H.LateError$fieldNI("_controller"));
                t1._subscribe$4(null, null, null, false).cancel$0();
                // goto return
                $async$goto = 1;
                break;
              }
              // goto for condition
              $async$goto = 4;
              break;
            case 5:
              // after for
              P.print("Sass is watching for changes. Press Ctrl-C to stop.\n");
              $async$goto = 7;
              return P._asyncAwait(watcher.watch$1(0, dirWatcher), $async$watch);
            case 7:
              // returning from await.
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$watch, $async$completer);
    },
    watch_closure: function watch_closure(t0) {
      this.dirWatcher = t0;
    },
    _Watcher: function _Watcher(t0, t1) {
      this._watch$_options = t0;
      this._graph = t1;
    },
    _Watcher__debounceEvents_closure: function _Watcher__debounceEvents_closure() {
    },
    MergedExtension_merge(left, right) {
      var t4, t5, t6,
        t1 = left.extender,
        t2 = t1.selector,
        t3 = C.C_ListEquality.equals$2(0, t2.components, right.extender.selector.components);
      if (!t3 || !left.target.$eq(0, right.target))
        throw H.wrapException(P.ArgumentError$(left.toString$0(0) + " and " + right.toString$0(0) + " aren't the same extension.", null));
      t3 = left.mediaContext;
      t4 = t3 == null;
      if (!t4) {
        t5 = right.mediaContext;
        t5 = t5 != null && !C.C_ListEquality.equals$2(0, t3, t5);
      } else
        t5 = false;
      if (t5)
        throw H.wrapException(E.SassException$("From " + left.span.message$1(0, "") + string$.x0aYou_m, right.span));
      if (right.isOptional && right.mediaContext == null)
        return left;
      if (left.isOptional && t4)
        return right;
      t5 = left.target;
      t6 = left.span;
      if (t4)
        t3 = right.mediaContext;
      t2.get$maxSpecificity();
      t1 = new S.Extender(t2, false, t1.span);
      return t1._extension = new A.MergedExtension(left, right, t1, t5, t3, true, t6);
    },
    MergedExtension: function MergedExtension(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.left = t0;
      _.right = t1;
      _.extender = t2;
      _.target = t3;
      _.mediaContext = t4;
      _.isOptional = t5;
      _.span = t6;
    },
    _modify(map, keys, modify, addNesting) {
      var keyIterator = J.get$iterator$ax(keys);
      return keyIterator.moveNext$0() ? new A._modify__modifyNestedMap(keyIterator, modify, addNesting).call$1(map) : modify.call$1(map);
    },
    _deepMergeImpl(map1, map2) {
      var t1 = {},
        t2 = map2.contents;
      if (t2.get$isEmpty(t2))
        return map1;
      t1.mutable = false;
      t1.result = t2;
      map1.contents.forEach$1(0, new A._deepMergeImpl_closure(t1, new A._deepMergeImpl__ensureMutable(t1)));
      if (t1.mutable) {
        t2 = type$.Value;
        t2 = new A.SassMap(H.ConstantMap_ConstantMap$from(t1.result, t2, t2));
        t1 = t2;
      } else
        t1 = map2;
      return t1;
    },
    _function2($name, $arguments, callback) {
      return Q.BuiltInCallable$function($name, $arguments, callback, "sass:map");
    },
    _get_closure: function _get_closure() {
    },
    _set_closure: function _set_closure() {
    },
    _set__closure0: function _set__closure0(t0) {
      this.$arguments = t0;
    },
    _set_closure0: function _set_closure0() {
    },
    _set__closure: function _set__closure(t0) {
      this.args = t0;
    },
    _merge_closure: function _merge_closure() {
    },
    _merge_closure0: function _merge_closure0() {
    },
    _merge__closure: function _merge__closure(t0) {
      this.map2 = t0;
    },
    _deepMerge_closure: function _deepMerge_closure() {
    },
    _deepRemove_closure: function _deepRemove_closure() {
    },
    _deepRemove__closure: function _deepRemove__closure(t0) {
      this.keys = t0;
    },
    _remove_closure: function _remove_closure() {
    },
    _remove_closure0: function _remove_closure0() {
    },
    _keys_closure: function _keys_closure() {
    },
    _values_closure: function _values_closure() {
    },
    _hasKey_closure: function _hasKey_closure() {
    },
    _modify__modifyNestedMap: function _modify__modifyNestedMap(t0, t1, t2) {
      this.keyIterator = t0;
      this.modify = t1;
      this.addNesting = t2;
    },
    _deepMergeImpl__ensureMutable: function _deepMergeImpl__ensureMutable(t0) {
      this._box_0 = t0;
    },
    _deepMergeImpl_closure: function _deepMergeImpl_closure(t0, t1) {
      this._box_0 = t0;
      this._ensureMutable = t1;
    },
    SassMap: function SassMap(t0) {
      this.contents = t0;
    },
    SassMap_asList_closure: function SassMap_asList_closure(t0) {
      this.result = t0;
    },
    _IterableExtension__search(_this, callback) {
      var t1, value;
      for (t1 = J.get$iterator$ax(_this); t1.moveNext$0();) {
        value = callback.call$1(t1.get$current(t1));
        if (value != null)
          return value;
      }
    },
    StatementSearchVisitor: function StatementSearchVisitor() {
    },
    StatementSearchVisitor_visitIfRule_closure: function StatementSearchVisitor_visitIfRule_closure(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure0: function StatementSearchVisitor_visitIfRule__closure0(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule_closure0: function StatementSearchVisitor_visitIfRule_closure0(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure: function StatementSearchVisitor_visitIfRule__closure(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitChildren_closure: function StatementSearchVisitor_visitChildren_closure(t0) {
      this.$this = t0;
    },
    Frame_Frame$parseVM(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseVM_closure(frame));
    },
    Frame_Frame$parseV8(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseV8_closure(frame));
    },
    Frame_Frame$_parseFirefoxEval(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$_parseFirefoxEval_closure(frame));
    },
    Frame_Frame$parseFirefox(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFirefox_closure(frame));
    },
    Frame_Frame$parseFriendly(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFriendly_closure(frame));
    },
    Frame__uriOrPathToUri(uriOrPath) {
      if (C.JSString_methods.contains$1(uriOrPath, $.$get$Frame__uriRegExp()))
        return P.Uri_parse(uriOrPath);
      else if (C.JSString_methods.contains$1(uriOrPath, $.$get$Frame__windowsRegExp()))
        return P._Uri__Uri$file(uriOrPath, true);
      else if (C.JSString_methods.startsWith$1(uriOrPath, "/"))
        return P._Uri__Uri$file(uriOrPath, false);
      if (C.JSString_methods.contains$1(uriOrPath, "\\"))
        return $.$get$windows().toUri$1(uriOrPath);
      return P.Uri_parse(uriOrPath);
    },
    Frame__catchFormatException(text, body) {
      var t1, exception;
      try {
        t1 = body.call$0();
        return t1;
      } catch (exception) {
        if (type$.FormatException._is(H.unwrapException(exception)))
          return new N.UnparsedFrame(P._Uri__Uri(null, "unparsed", null, null), text);
        else
          throw exception;
      }
    },
    Frame: function Frame(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.line = t1;
      _.column = t2;
      _.member = t3;
    },
    Frame_Frame$parseVM_closure: function Frame_Frame$parseVM_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseV8_closure: function Frame_Frame$parseV8_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseV8_closure_parseLocation: function Frame_Frame$parseV8_closure_parseLocation(t0) {
      this.frame = t0;
    },
    Frame_Frame$_parseFirefoxEval_closure: function Frame_Frame$_parseFirefoxEval_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseFirefox_closure: function Frame_Frame$parseFirefox_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseFriendly_closure: function Frame_Frame$parseFriendly_closure(t0) {
      this.frame = t0;
    },
    AsciiGlyphSet: function AsciiGlyphSet() {
    },
    Configuration0: function Configuration0(t0) {
      this._configuration$_values = t0;
    },
    Configuration_toString_closure0: function Configuration_toString_closure0() {
    },
    ExplicitConfiguration0: function ExplicitConfiguration0(t0, t1) {
      this.nodeWithSpan = t0;
      this._configuration$_values = t1;
    },
    IncludeRule0: function IncludeRule0(t0, t1, t2, t3, t4) {
      var _ = this;
      _.namespace = t0;
      _.name = t1;
      _.$arguments = t2;
      _.content = t3;
      _.span = t4;
    },
    MapExpression0: function MapExpression0(t0, t1) {
      this.pairs = t0;
      this.span = t1;
    },
    MapExpression_toString_closure0: function MapExpression_toString_closure0() {
    },
    _modify0(map, keys, modify, addNesting) {
      var keyIterator = J.get$iterator$ax(keys);
      return keyIterator.moveNext$0() ? new A._modify__modifyNestedMap0(keyIterator, modify, addNesting).call$1(map) : modify.call$1(map);
    },
    _deepMergeImpl0(map1, map2) {
      var t1 = {},
        t2 = map2.contents;
      if (t2.get$isEmpty(t2))
        return map1;
      t1.mutable = false;
      t1.result = t2;
      map1.contents.forEach$1(0, new A._deepMergeImpl_closure0(t1, new A._deepMergeImpl__ensureMutable0(t1)));
      if (t1.mutable) {
        t2 = type$.Value_2;
        t2 = new A.SassMap0(H.ConstantMap_ConstantMap$from(t1.result, t2, t2));
        t1 = t2;
      } else
        t1 = map2;
      return t1;
    },
    _function9($name, $arguments, callback) {
      return Q.BuiltInCallable$function0($name, $arguments, callback, "sass:map");
    },
    _get_closure0: function _get_closure0() {
    },
    _set_closure1: function _set_closure1() {
    },
    _set__closure2: function _set__closure2(t0) {
      this.$arguments = t0;
    },
    _set_closure2: function _set_closure2() {
    },
    _set__closure1: function _set__closure1(t0) {
      this.args = t0;
    },
    _merge_closure1: function _merge_closure1() {
    },
    _merge_closure2: function _merge_closure2() {
    },
    _merge__closure0: function _merge__closure0(t0) {
      this.map2 = t0;
    },
    _deepMerge_closure0: function _deepMerge_closure0() {
    },
    _deepRemove_closure0: function _deepRemove_closure0() {
    },
    _deepRemove__closure0: function _deepRemove__closure0(t0) {
      this.keys = t0;
    },
    _remove_closure1: function _remove_closure1() {
    },
    _remove_closure2: function _remove_closure2() {
    },
    _keys_closure0: function _keys_closure0() {
    },
    _values_closure0: function _values_closure0() {
    },
    _hasKey_closure0: function _hasKey_closure0() {
    },
    _modify__modifyNestedMap0: function _modify__modifyNestedMap0(t0, t1, t2) {
      this.keyIterator = t0;
      this.modify = t1;
      this.addNesting = t2;
    },
    _deepMergeImpl__ensureMutable0: function _deepMergeImpl__ensureMutable0(t0) {
      this._box_0 = t0;
    },
    _deepMergeImpl_closure0: function _deepMergeImpl_closure0(t0, t1) {
      this._box_0 = t0;
      this._ensureMutable = t1;
    },
    _NodeSassMap: function _NodeSassMap() {
    },
    mapConstructor_closure: function mapConstructor_closure() {
    },
    mapConstructor__closure: function mapConstructor__closure() {
    },
    mapConstructor__closure0: function mapConstructor__closure0() {
    },
    mapConstructor_closure0: function mapConstructor_closure0() {
    },
    mapConstructor_closure1: function mapConstructor_closure1() {
    },
    mapConstructor_closure2: function mapConstructor_closure2() {
    },
    mapConstructor_closure3: function mapConstructor_closure3() {
    },
    mapConstructor_closure4: function mapConstructor_closure4() {
    },
    mapConstructor_closure5: function mapConstructor_closure5() {
    },
    SassMap0: function SassMap0(t0) {
      this.contents = t0;
    },
    SassMap_asList_closure0: function SassMap_asList_closure0(t0) {
      this.result = t0;
    },
    MergedExtension_merge0(left, right) {
      var t4, t5, t6,
        t1 = left.extender,
        t2 = t1.selector,
        t3 = C.C_ListEquality.equals$2(0, t2.components, right.extender.selector.components);
      if (!t3 || !left.target.$eq(0, right.target))
        throw H.wrapException(P.ArgumentError$(left.toString$0(0) + " and " + right.toString$0(0) + " aren't the same extension.", null));
      t3 = left.mediaContext;
      t4 = t3 == null;
      if (!t4) {
        t5 = right.mediaContext;
        t5 = t5 != null && !C.C_ListEquality.equals$2(0, t3, t5);
      } else
        t5 = false;
      if (t5)
        throw H.wrapException(E.SassException$0("From " + left.span.message$1(0, "") + string$.x0aYou_m, right.span));
      if (right.isOptional && right.mediaContext == null)
        return left;
      if (left.isOptional && t4)
        return right;
      t5 = left.target;
      t6 = left.span;
      if (t4)
        t3 = right.mediaContext;
      t2.get$maxSpecificity();
      t1 = new S.Extender0(t2, false, t1.span);
      return t1._extension$_extension = new A.MergedExtension0(left, right, t1, t5, t3, true, t6);
    },
    MergedExtension0: function MergedExtension0(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.left = t0;
      _.right = t1;
      _.extender = t2;
      _.target = t3;
      _.mediaContext = t4;
      _.isOptional = t5;
      _.span = t6;
    },
    _IterableExtension__search0(_this, callback) {
      var t1, value;
      for (t1 = J.get$iterator$ax(_this); t1.moveNext$0();) {
        value = callback.call$1(t1.get$current(t1));
        if (value != null)
          return value;
      }
    },
    StatementSearchVisitor0: function StatementSearchVisitor0() {
    },
    StatementSearchVisitor_visitIfRule_closure1: function StatementSearchVisitor_visitIfRule_closure1(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure2: function StatementSearchVisitor_visitIfRule__closure2(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule_closure2: function StatementSearchVisitor_visitIfRule_closure2(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure1: function StatementSearchVisitor_visitIfRule__closure1(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitChildren_closure0: function StatementSearchVisitor_visitChildren_closure0(t0) {
      this.$this = t0;
    },
    IterableNullableExtension_whereNotNull(_this, $T) {
      return A.IterableNullableExtension_whereNotNull$body(_this, $T, $T);
    },
    IterableNullableExtension_whereNotNull$body($async$_this, $async$$T, $async$type) {
      return P._makeSyncStarIterable(function() {
        var _this = $async$_this,
          $T = $async$$T;
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1, element;
        return function $async$IterableNullableExtension_whereNotNull($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = _this.get$iterator(_this);
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                element = t1.get$current(t1);
                $async$goto = element != null ? 4 : 5;
                break;
              case 4:
                // then
                $async$goto = 6;
                return element;
              case 6:
                // after yield
              case 5:
                // join
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, $async$type);
    },
    IterableIntegerExtension_get_sum(_this) {
      var t1, t2, result;
      for (t1 = new H.MappedIterator(J.get$iterator$ax(_this.__internal$_iterable), _this._f), t2 = H._instanceType(t1)._rest[1], result = 0; t1.moveNext$0();)
        result += t2._as(t1.__internal$_current);
      return result;
    },
    _combine(hash, value) {
      hash = hash + value & 536870911;
      hash = hash + ((hash & 524287) << 10) & 536870911;
      return hash ^ hash >>> 6;
    },
    _finish(hash) {
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >>> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    }
  },
  B = {ReplAdapter: function ReplAdapter(t0) {
      this.repl = t0;
      this.rl = null;
    }, ReplAdapter_runAsync_closure: function ReplAdapter_runAsync_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.rl = t2;
      _.runController = t3;
    }, ReplAdapter_runAsync__closure: function ReplAdapter_runAsync__closure(t0) {
      this.lineController = t0;
    }, Stdin: function Stdin() {
    }, Stdout: function Stdout() {
    }, ReadlineModule: function ReadlineModule() {
    }, ReadlineOptions: function ReadlineOptions() {
    }, ReadlineInterface: function ReadlineInterface() {
    }, InternalStyle: function InternalStyle() {
    }, ModifiableCssNode: function ModifiableCssNode() {
    }, ModifiableCssParentNode: function ModifiableCssParentNode() {
    },
    ModifiableCssSupportsRule$(condition, span) {
      var t1 = H._setArrayType([], type$.JSArray_ModifiableCssNode);
      return new B.ModifiableCssSupportsRule(condition, span, new P.UnmodifiableListView(t1, type$.UnmodifiableListView_ModifiableCssNode), t1);
    },
    ModifiableCssSupportsRule: function ModifiableCssSupportsRule(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _._children = t3;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    CssNode: function CssNode() {
    },
    CssParentNode: function CssParentNode() {
    },
    AstNode: function AstNode() {
    },
    _FakeAstNode: function _FakeAstNode(t0) {
      this._callback = t0;
    },
    ArgumentDeclaration_ArgumentDeclaration$parse(contents, url) {
      return L.ScssParser$(contents, null, url).parseArgumentDeclaration$0();
    },
    ArgumentDeclaration: function ArgumentDeclaration(t0, t1, t2) {
      this.$arguments = t0;
      this.restArgument = t1;
      this.span = t2;
    },
    ArgumentDeclaration_verify_closure: function ArgumentDeclaration_verify_closure() {
    },
    ArgumentDeclaration_verify_closure0: function ArgumentDeclaration_verify_closure0() {
    },
    DynamicImport: function DynamicImport(t0, t1) {
      this.urlString = t0;
      this.span = t1;
    },
    ForRule$(variable, from, to, children, span, exclusive) {
      var t1 = P.List_List$unmodifiable(children, type$.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new B.ForRule(variable, from, to, exclusive, span, t1, t2);
    },
    ForRule: function ForRule(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.variable = t0;
      _.from = t1;
      _.to = t2;
      _.isExclusive = t3;
      _.span = t4;
      _.children = t5;
      _.hasDeclarations = t6;
    },
    ImportRule: function ImportRule(t0, t1) {
      this.imports = t0;
      this.span = t1;
    },
    ReturnRule: function ReturnRule(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    SilentComment: function SilentComment(t0, t1) {
      this.text = t0;
      this.span = t1;
    },
    SupportsRule$(condition, children, span) {
      var t1 = P.List_List$unmodifiable(children, type$.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new B.SupportsRule(condition, span, t1, t2);
    },
    SupportsRule: function SupportsRule(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    ExecutableOptions__separator(text) {
      var t1 = $.$get$ExecutableOptions__separatorBar(),
        t2 = C.JSString_methods.$mul(t1, 3) + " ";
      t2 = t2 + (J.$eq$(self.process.stdout.isTTY, true) ? "\x1b[1m" : "") + text;
      return t2 + (J.$eq$(self.process.stdout.isTTY, true) ? "\x1b[0m" : "") + " " + C.JSString_methods.$mul(t1, 35 - text.length);
    },
    ExecutableOptions__fail(message) {
      return H.throwExpression(B.UsageException$(message));
    },
    ExecutableOptions_ExecutableOptions$parse(args) {
      var options, error, t1, exception;
      try {
        t1 = G.Parser$(null, $.$get$ExecutableOptions__parser(), P.ListQueue_ListQueue$of(args, type$.String), null, null).parse$0();
        if (t1.wasParsed$1("poll") && !H._asBool(t1.$index(0, "watch")))
          B.ExecutableOptions__fail("--poll may not be passed without --watch.");
        options = new B.ExecutableOptions(t1);
        if (H._asBool(options._options.$index(0, "help")))
          B.ExecutableOptions__fail("Compile Sass to CSS.");
        return options;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (type$.FormatException._is(t1)) {
          error = t1;
          B.ExecutableOptions__fail(J.get$message$x(error));
        } else
          throw exception;
      }
    },
    UsageException$(message) {
      return new B.UsageException(message);
    },
    ExecutableOptions: function ExecutableOptions(t0) {
      var _ = this;
      _._options = t0;
      _.__ExecutableOptions__sourceDirectoriesToDestinations = _._sourcesToDestinations = _.__ExecutableOptions_interactive = null;
    },
    ExecutableOptions__parser_closure: function ExecutableOptions__parser_closure() {
    },
    ExecutableOptions_interactive_closure: function ExecutableOptions_interactive_closure(t0) {
      this.$this = t0;
    },
    ExecutableOptions_emitErrorCss_closure: function ExecutableOptions_emitErrorCss_closure() {
    },
    UsageException: function UsageException(t0) {
      this.message = t0;
    },
    AsyncImporter: function AsyncImporter() {
    },
    fromImport() {
      var t1 = H._asBoolQ($.Zone__current.$index(0, C.Symbol__inImportRule));
      return t1 === true;
    },
    resolveImportPath(path) {
      var t1,
        extension = X.ParsedPath_ParsedPath$parse(path, $.$get$context().style)._splitExtension$1(1)[1];
      if (extension === ".sass" || extension === ".scss" || extension === ".css") {
        t1 = B.fromImport() ? new B.resolveImportPath_closure(path, extension).call$0() : null;
        return t1 == null ? B._exactlyOne(B._tryPath(path)) : t1;
      }
      t1 = B.fromImport() ? new B.resolveImportPath_closure0(path).call$0() : null;
      if (t1 == null)
        t1 = B._exactlyOne(B._tryPathWithExtensions(path));
      return t1 == null ? B._tryPathAsDirectory(path) : t1;
    },
    _tryPathWithExtensions(path) {
      var result = B._tryPath(path + ".sass");
      C.JSArray_methods.addAll$1(result, B._tryPath(path + ".scss"));
      return result.length !== 0 ? result : B._tryPath(path + ".css");
    },
    _tryPath(path) {
      var t1 = $.$get$context(),
        partial = D.join(t1.dirname$1(path), "_" + X.ParsedPath_ParsedPath$parse(path, t1.style).get$basename(), null);
      t1 = H._setArrayType([], type$.JSArray_String);
      if (B.fileExists(partial))
        t1.push(partial);
      if (B.fileExists(path))
        t1.push(path);
      return t1;
    },
    _tryPathAsDirectory(path) {
      var t1;
      if (!B.dirExists(path))
        return null;
      t1 = B.fromImport() ? new B._tryPathAsDirectory_closure(path).call$0() : null;
      return t1 == null ? B._exactlyOne(B._tryPathWithExtensions(D.join(path, "index", null))) : t1;
    },
    _exactlyOne(paths) {
      var t1 = paths.length;
      if (t1 === 0)
        return null;
      if (t1 === 1)
        return C.JSArray_methods.get$first(paths);
      throw H.wrapException(string$.It_s_n + C.JSArray_methods.map$1$1(paths, new B._exactlyOne_closure(), type$.String).join$1(0, "\n"));
    },
    resolveImportPath_closure: function resolveImportPath_closure(t0, t1) {
      this.path = t0;
      this.extension = t1;
    },
    resolveImportPath_closure0: function resolveImportPath_closure0(t0) {
      this.path = t0;
    },
    _tryPathAsDirectory_closure: function _tryPathAsDirectory_closure(t0) {
      this.path = t0;
    },
    _exactlyOne_closure: function _exactlyOne_closure() {
    },
    readFile(path) {
      var sourceFile, t1, i,
        contents = H._asString(B._readFile(path, "utf8"));
      if (!C.JSString_methods.contains$1(contents, "\ufffd"))
        return contents;
      sourceFile = Y.SourceFile$fromString(contents, $.$get$context().toUri$1(path));
      for (t1 = contents.length, i = 0; i < t1; ++i) {
        if (C.JSString_methods._codeUnitAt$1(contents, i) !== 65533)
          continue;
        throw H.wrapException(E.SassException$("Invalid UTF-8.", Y.FileLocation$_(sourceFile, i).pointSpan$0()));
      }
      return contents;
    },
    _readFile(path, encoding) {
      return B._systemErrorToFileSystemException(new B._readFile_closure(path, encoding));
    },
    writeFile(path, contents) {
      return B._systemErrorToFileSystemException(new B.writeFile_closure(path, contents));
    },
    deleteFile(path) {
      return B._systemErrorToFileSystemException(new B.deleteFile_closure(path));
    },
    readStdin() {
      return B.readStdin$body();
    },
    readStdin$body() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(type$.String),
        $async$returnValue, sink, t1, t2, completer;
      var $async$readStdin = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t2 = new P._Future($.Zone__current, type$._Future_String);
              completer = new P._AsyncCompleter(t2, type$._AsyncCompleter_String);
              t1.contents = null;
              sink = new P._StringCallbackSink(new B.readStdin_closure(t1, completer), new P.StringBuffer("")).asUtf8Sink$1(false);
              J.on$2$x(J.get$stdin$x(self.process), "data", P.allowInterop(new B.readStdin_closure0(sink)));
              J.on$2$x(J.get$stdin$x(self.process), "end", P.allowInterop(new B.readStdin_closure1(sink)));
              J.on$2$x(J.get$stdin$x(self.process), "error", P.allowInterop(new B.readStdin_closure2(completer)));
              $async$returnValue = t2;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$readStdin, $async$completer);
    },
    fileExists(path) {
      return B._systemErrorToFileSystemException(new B.fileExists_closure(path));
    },
    dirExists(path) {
      return B._systemErrorToFileSystemException(new B.dirExists_closure(path));
    },
    ensureDir(path) {
      return B._systemErrorToFileSystemException(new B.ensureDir_closure(path));
    },
    listDir(path, recursive) {
      return B._systemErrorToFileSystemException(new B.listDir_closure(recursive, path));
    },
    modificationTime(path) {
      return B._systemErrorToFileSystemException(new B.modificationTime_closure(path));
    },
    _systemErrorToFileSystemException(callback) {
      var error, systemError, t1, exception, t2;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = type$.JsSystemError._as(error);
        t1 = systemError;
        t2 = J.getInterceptor$x(t1);
        throw H.wrapException(new B.FileSystemException(J.substring$2$s(t2.get$message(t1), (H.S(t2.get$code(t1)) + ": ").length, J.get$length$asx(t2.get$message(t1)) - (", " + H.S(t2.get$syscall(t1)) + " '" + H.S(t2.get$path(t1)) + "'").length), J.get$path$x(systemError)));
      }
    },
    isWindows() {
      return J.$eq$(J.get$platform$x(self.process), "win32");
    },
    watchDir(path, poll) {
      var t2, t3, t1 = {},
        watcher = J.watch$2$x(self.chokidar, path, {disableGlobbing: true, usePolling: poll});
      t1.controller = null;
      t2 = J.getInterceptor$x(watcher);
      t2.on$2(watcher, "add", P.allowInterop(new B.watchDir_closure(t1)));
      t2.on$2(watcher, "change", P.allowInterop(new B.watchDir_closure0(t1)));
      t2.on$2(watcher, "unlink", P.allowInterop(new B.watchDir_closure1(t1)));
      t2.on$2(watcher, "error", P.allowInterop(new B.watchDir_closure2(t1)));
      t3 = new P._Future($.Zone__current, type$._Future_Stream_WatchEvent);
      t2.on$2(watcher, "ready", P.allowInterop(new B.watchDir_closure3(t1, watcher, new P._AsyncCompleter(t3, type$._AsyncCompleter_Stream_WatchEvent))));
      return t3;
    },
    FileSystemException: function FileSystemException(t0, t1) {
      this.message = t0;
      this.path = t1;
    },
    Stderr: function Stderr(t0) {
      this._stderr = t0;
    },
    _readFile_closure: function _readFile_closure(t0, t1) {
      this.path = t0;
      this.encoding = t1;
    },
    writeFile_closure: function writeFile_closure(t0, t1) {
      this.path = t0;
      this.contents = t1;
    },
    deleteFile_closure: function deleteFile_closure(t0) {
      this.path = t0;
    },
    readStdin_closure: function readStdin_closure(t0, t1) {
      this._box_0 = t0;
      this.completer = t1;
    },
    readStdin_closure0: function readStdin_closure0(t0) {
      this.sink = t0;
    },
    readStdin_closure1: function readStdin_closure1(t0) {
      this.sink = t0;
    },
    readStdin_closure2: function readStdin_closure2(t0) {
      this.completer = t0;
    },
    fileExists_closure: function fileExists_closure(t0) {
      this.path = t0;
    },
    dirExists_closure: function dirExists_closure(t0) {
      this.path = t0;
    },
    ensureDir_closure: function ensureDir_closure(t0) {
      this.path = t0;
    },
    listDir_closure: function listDir_closure(t0, t1) {
      this.recursive = t0;
      this.path = t1;
    },
    listDir__closure: function listDir__closure(t0) {
      this.path = t0;
    },
    listDir__closure0: function listDir__closure0() {
    },
    listDir_closure_list: function listDir_closure_list() {
    },
    listDir__list_closure: function listDir__list_closure(t0, t1) {
      this.parent = t0;
      this.list = t1;
    },
    modificationTime_closure: function modificationTime_closure(t0) {
      this.path = t0;
    },
    watchDir_closure: function watchDir_closure(t0) {
      this._box_0 = t0;
    },
    watchDir_closure0: function watchDir_closure0(t0) {
      this._box_0 = t0;
    },
    watchDir_closure1: function watchDir_closure1(t0) {
      this._box_0 = t0;
    },
    watchDir_closure2: function watchDir_closure2(t0) {
      this._box_0 = t0;
    },
    watchDir_closure3: function watchDir_closure3(t0, t1, t2) {
      this._box_0 = t0;
      this.watcher = t1;
      this.completer = t2;
    },
    watchDir__closure: function watchDir__closure(t0) {
      this.watcher = t0;
    },
    ShadowedModuleView_ifNecessary(inner, functions, mixins, variables, $T) {
      return B.ShadowedModuleView__needsBlocklist(inner.get$variables(), variables) || B.ShadowedModuleView__needsBlocklist(inner.get$functions(inner), functions) || B.ShadowedModuleView__needsBlocklist(inner.get$mixins(), mixins) ? new B.ShadowedModuleView(inner, B.ShadowedModuleView__shadowedMap(inner.get$variables(), variables, type$.Value), B.ShadowedModuleView__shadowedMap(inner.get$variableNodes(), variables, type$.AstNode), B.ShadowedModuleView__shadowedMap(inner.get$functions(inner), functions, $T), B.ShadowedModuleView__shadowedMap(inner.get$mixins(), mixins, $T), $T._eval$1("ShadowedModuleView<0>")) : null;
    },
    ShadowedModuleView__shadowedMap(map, blocklist, $V) {
      var t1 = B.ShadowedModuleView__needsBlocklist(map, blocklist);
      return !t1 ? map : K.LimitedMapView$blocklist(map, blocklist, type$.String, $V);
    },
    ShadowedModuleView__needsBlocklist(map, blocklist) {
      var t1 = map.get$isNotEmpty(map) && blocklist.any$1(0, map.get$containsKey());
      return t1;
    },
    ShadowedModuleView: function ShadowedModuleView(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._shadowed_view$_inner = t0;
      _.variables = t1;
      _.variableNodes = t2;
      _.functions = t3;
      _.mixins = t4;
      _.$ti = t5;
    },
    _PropertyDescriptor: function _PropertyDescriptor() {
    },
    toSentence(iter, conjunction) {
      var t1 = iter.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1);
      if (t2.get$length(t1) === 1)
        return J.toString$0$(iter._f.call$1(t2.get$first(t1)));
      return H.TakeIterable_TakeIterable(iter, t2.get$length(t1) - 1, H._instanceType(iter)._eval$1("Iterable.E")).join$1(0, ", ") + (" " + conjunction + " " + H.S(iter._f.call$1(t2.get$last(t1))));
    },
    indent(string, indentation) {
      return new H.MappedListIterable(H._setArrayType(string.split("\n"), type$.JSArray_String), new B.indent_closure(indentation), type$.MappedListIterable_String_String).join$1(0, "\n");
    },
    pluralize($name, number, plural) {
      if (number === 1)
        return $name;
      if (plural != null)
        return plural;
      return $name + "s";
    },
    trimAscii(string, excludeEscape) {
      var t1,
        start = B._firstNonWhitespace(string);
      if (start == null)
        t1 = "";
      else {
        t1 = B._lastNonWhitespace(string, true);
        t1.toString;
        t1 = C.JSString_methods.substring$2(string, start, t1 + 1);
      }
      return t1;
    },
    trimAsciiRight(string, excludeEscape) {
      var end = B._lastNonWhitespace(string, excludeEscape);
      return end == null ? "" : C.JSString_methods.substring$2(string, 0, end + 1);
    },
    _firstNonWhitespace(string) {
      var t1, i, t2;
      for (t1 = string.length, i = 0; i < t1; ++i) {
        t2 = C.JSString_methods._codeUnitAt$1(string, i);
        if (!(t2 === 32 || t2 === 9 || t2 === 10 || t2 === 13 || t2 === 12))
          return i;
      }
      return null;
    },
    _lastNonWhitespace(string, excludeEscape) {
      var t1, i, codeUnit;
      for (t1 = string.length, i = t1 - 1; i >= 0; --i) {
        codeUnit = C.JSString_methods.codeUnitAt$1(string, i);
        if (!(codeUnit === 32 || codeUnit === 9 || codeUnit === 10 || codeUnit === 13 || codeUnit === 12))
          if (excludeEscape && i !== 0 && i !== t1 && codeUnit === 92)
            return i + 1;
          else
            return i;
      }
      return null;
    },
    isPublic(member) {
      var start = C.JSString_methods._codeUnitAt$1(member, 0);
      return start !== 45 && start !== 95;
    },
    flattenVertically(iterable, $T) {
      var result,
        t1 = iterable.$ti._eval$1("@<ListIterable.E>")._bind$1($T._eval$1("QueueList<0>"))._eval$1("MappedListIterable<1,2>"),
        queues = P.List_List$of(new H.MappedListIterable(iterable, new B.flattenVertically_closure($T), t1), true, t1._eval$1("ListIterable.E"));
      if (queues.length === 1)
        return C.JSArray_methods.get$first(queues);
      result = H._setArrayType([], $T._eval$1("JSArray<0>"));
      for (; queues.length !== 0;) {
        if (!!queues.fixed$length)
          H.throwExpression(P.UnsupportedError$("removeWhere"));
        C.JSArray_methods._removeWhere$2(queues, new B.flattenVertically_closure0(result, $T), true);
      }
      return result;
    },
    firstOrNull(iterable) {
      var iterator = J.get$iterator$ax(iterable);
      return iterator.moveNext$0() ? iterator.get$current(iterator) : null;
    },
    codepointIndexToCodeUnitIndex(string, codepointIndex) {
      var codeUnitIndex, i, codeUnitIndex0;
      for (codeUnitIndex = 0, i = 0; i < codepointIndex; ++i) {
        codeUnitIndex0 = codeUnitIndex + 1;
        codeUnitIndex = C.JSString_methods._codeUnitAt$1(string, codeUnitIndex) >>> 10 === 54 ? codeUnitIndex0 + 1 : codeUnitIndex0;
      }
      return codeUnitIndex;
    },
    codeUnitIndexToCodepointIndex(string, codeUnitIndex) {
      var codepointIndex, i;
      for (codepointIndex = 0, i = 0; i < codeUnitIndex; i = (C.JSString_methods._codeUnitAt$1(string, i) >>> 10 === 54 ? i + 1 : i) + 1)
        ++codepointIndex;
      return codepointIndex;
    },
    frameForSpan(span, member, url) {
      var t2, t3, t4,
        t1 = url == null ? span.file.url : url;
      if (t1 == null)
        t1 = $.$get$_noSourceUrl();
      t2 = span.file;
      t3 = span._file$_start;
      t4 = Y.FileLocation$_(t2, t3);
      t4 = t4.file.getLine$1(t4.offset);
      t3 = Y.FileLocation$_(t2, t3);
      return new A.Frame(t1, t4 + 1, t3.file.getColumn$1(t3.offset) + 1, member);
    },
    declarationName(span) {
      var text = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(span.file._decodedChars, span._file$_start, span._end), 0, null);
      return B.trimAsciiRight(C.JSString_methods.substring$2(text, 0, C.JSString_methods.indexOf$1(text, ":")), false);
    },
    unvendor($name) {
      var i,
        t1 = $name.length;
      if (t1 < 2)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 0) !== 45)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 1) === 45)
        return $name;
      for (i = 2; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1($name, i) === 45)
          return C.JSString_methods.substring$1($name, i + 1);
      return $name;
    },
    equalsIgnoreCase(string1, string2) {
      var t1, i;
      if (string1 === string2)
        return true;
      if (string1 == null || false)
        return false;
      t1 = string1.length;
      if (t1 !== string2.length)
        return false;
      for (i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase(C.JSString_methods._codeUnitAt$1(string1, i), C.JSString_methods._codeUnitAt$1(string2, i)))
          return false;
      return true;
    },
    startsWithIgnoreCase(string, prefix) {
      var i,
        t1 = prefix.length;
      if (string.length < t1)
        return false;
      for (i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase(C.JSString_methods._codeUnitAt$1(string, i), C.JSString_methods._codeUnitAt$1(prefix, i)))
          return false;
      return true;
    },
    mapInPlace(list, $function) {
      var i;
      for (i = 0; i < list.length; ++i)
        list[i] = $function.call$1(list[i]);
    },
    longestCommonSubsequence(list1, list2, select, $T) {
      var t1, _length, lengths, t2, t3, _i, selections, i, i0, j, selection, j0;
      if (select == null)
        select = new B.longestCommonSubsequence_closure($T);
      t1 = J.getInterceptor$asx(list1);
      _length = t1.get$length(list1) + 1;
      lengths = J.JSArray_JSArray$allocateFixed(_length, type$.List_int);
      for (t2 = J.getInterceptor$asx(list2), t3 = type$.int, _i = 0; _i < _length; ++_i)
        lengths[_i] = P.List_List$filled(t2.get$length(list2) + 1, 0, false, t3);
      _length = t1.get$length(list1);
      selections = J.JSArray_JSArray$allocateFixed(_length, $T._eval$1("List<0?>"));
      for (t3 = $T._eval$1("0?"), _i = 0; _i < _length; ++_i)
        selections[_i] = P.List_List$filled(t2.get$length(list2), null, false, t3);
      for (i = 0; i < t1.get$length(list1); i = i0)
        for (i0 = i + 1, j = 0; j < t2.get$length(list2); j = j0) {
          selection = select.call$2(t1.$index(list1, i), t2.$index(list2, j));
          selections[i][j] = selection;
          t3 = lengths[i0];
          j0 = j + 1;
          t3[j0] = selection == null ? Math.max(t3[j], lengths[i][j0]) : lengths[i][j] + 1;
        }
      return new B.longestCommonSubsequence_backtrack(selections, lengths, $T).call$2(t1.get$length(list1) - 1, t2.get$length(list2) - 1);
    },
    removeFirstWhere(list, test, orElse) {
      var i;
      for (i = 0; i < list.length; ++i) {
        if (!test.call$1(list[i]))
          continue;
        C.JSArray_methods.removeAt$1(list, i);
        return;
      }
      orElse.call$0();
    },
    mapAddAll2(destination, source, K1, K2, $V) {
      source.forEach$1(0, new B.mapAddAll2_closure(destination, K1, K2, $V));
    },
    setAll(map, keys, value) {
      var t1;
      for (t1 = J.get$iterator$ax(keys); t1.moveNext$0();)
        map.$indexSet(0, t1.get$current(t1), value);
    },
    rotateSlice(list, start, end) {
      var i, next,
        element = list.$index(0, end - 1);
      for (i = start; i < end; ++i, element = next) {
        next = list.$index(0, i);
        list.$indexSet(0, i, element);
      }
    },
    mapAsync(iterable, callback, $E, $F) {
      return B.mapAsync$body(iterable, callback, $E, $F, $F._eval$1("Iterable<0>"));
    },
    mapAsync$body(iterable, callback, $E, $F, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t2, _i, t1, $async$temp1;
      var $async$mapAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H._setArrayType([], $F._eval$1("JSArray<0>"));
              t2 = iterable.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = t1;
              $async$goto = 6;
              return P._asyncAwait(callback.call$1(iterable[_i]), $async$mapAsync);
            case 6:
              // returning from await.
              $async$temp1.push($async$result);
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$mapAsync, $async$completer);
    },
    putIfAbsentAsync(map, key, ifAbsent, $K, $V) {
      return B.putIfAbsentAsync$body(map, key, ifAbsent, $K, $V, $V);
    },
    putIfAbsentAsync$body(map, key, ifAbsent, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, value;
      var $async$putIfAbsentAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (map.containsKey$1(key)) {
                $async$returnValue = $V._as(map.$index(0, key));
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(ifAbsent.call$0(), $async$putIfAbsentAsync);
            case 3:
              // returning from await.
              value = $async$result;
              map.$indexSet(0, key, value);
              $async$returnValue = value;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$putIfAbsentAsync, $async$completer);
    },
    copyMapOfMap(map, K1, K2, $V) {
      var t2, t3, t4, t5,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(K1, K2._eval$1("@<0>")._bind$1($V)._eval$1("Map<1,2>"));
      for (t2 = map.get$entries(map), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        t4 = t3.key;
        t3 = t3.value;
        t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, K2, $V);
        t5.addAll$1(0, t3);
        t1.$indexSet(0, t4, t5);
      }
      return t1;
    },
    copyMapOfList(map, $K, $E) {
      var t2, t3,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty($K, $E._eval$1("List<0>"));
      for (t2 = map.get$entries(map), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        t1.$indexSet(0, t3.key, J.toList$0$ax(t3.value));
      }
      return t1;
    },
    consumeEscapedCharacter(scanner) {
      var first, value, i, next, t1;
      scanner.expectChar$1(92);
      first = scanner.peekChar$0();
      if (first == null)
        return 65533;
      else if (first === 10 || first === 13 || first === 12)
        scanner.error$1(0, "Expected escape sequence.");
      else if (T.isHex(first)) {
        for (value = 0, i = 0; i < 6; ++i) {
          next = scanner.peekChar$0();
          if (next == null || !T.isHex(next))
            break;
          value = (value << 4 >>> 0) + T.asHex(scanner.readChar$0());
        }
        t1 = scanner.peekChar$0();
        if (t1 === 32 || t1 === 9 || t1 === 10 || t1 === 13 || t1 === 12)
          scanner.readChar$0();
        if (value !== 0)
          t1 = value >= 55296 && value <= 57343 || value >= 1114111;
        else
          t1 = true;
        if (t1)
          return 65533;
        else
          return value;
      } else
        return scanner.readChar$0();
    },
    indent_closure: function indent_closure(t0) {
      this.indentation = t0;
    },
    flattenVertically_closure: function flattenVertically_closure(t0) {
      this.T = t0;
    },
    flattenVertically_closure0: function flattenVertically_closure0(t0, t1) {
      this.result = t0;
      this.T = t1;
    },
    longestCommonSubsequence_closure: function longestCommonSubsequence_closure(t0) {
      this.T = t0;
    },
    longestCommonSubsequence_backtrack: function longestCommonSubsequence_backtrack(t0, t1, t2) {
      this.selections = t0;
      this.lengths = t1;
      this.T = t2;
    },
    mapAddAll2_closure: function mapAddAll2_closure(t0, t1, t2, t3) {
      var _ = this;
      _.destination = t0;
      _.K1 = t1;
      _.K2 = t2;
      _.V = t3;
    },
    ArgumentDeclaration_ArgumentDeclaration$parse0(contents, url) {
      return L.ScssParser$0(contents, null, url).parseArgumentDeclaration$0();
    },
    ArgumentDeclaration0: function ArgumentDeclaration0(t0, t1, t2) {
      this.$arguments = t0;
      this.restArgument = t1;
      this.span = t2;
    },
    ArgumentDeclaration_verify_closure1: function ArgumentDeclaration_verify_closure1() {
    },
    ArgumentDeclaration_verify_closure2: function ArgumentDeclaration_verify_closure2() {
    },
    AsyncImporter0: function AsyncImporter0() {
    },
    DynamicImport0: function DynamicImport0(t0, t1) {
      this.urlString = t0;
      this.span = t1;
    },
    ForRule$0(variable, from, to, children, span, exclusive) {
      var t1 = P.List_List$unmodifiable(children, type$.Statement_2),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure0());
      return new B.ForRule0(variable, from, to, exclusive, span, t1, t2);
    },
    ForRule0: function ForRule0(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.variable = t0;
      _.from = t1;
      _.to = t2;
      _.isExclusive = t3;
      _.span = t4;
      _.children = t5;
      _.hasDeclarations = t6;
    },
    ImportRule0: function ImportRule0(t0, t1) {
      this.imports = t0;
      this.span = t1;
    },
    AstNode0: function AstNode0() {
    },
    _FakeAstNode0: function _FakeAstNode0(t0) {
      this._node3$_callback = t0;
    },
    CssNode0: function CssNode0() {
    },
    CssParentNode0: function CssParentNode0() {
    },
    readFile0(path) {
      var sourceFile, t1, i,
        contents = H._asString(B._readFile0(path, "utf8"));
      if (!C.JSString_methods.contains$1(contents, "\ufffd"))
        return contents;
      sourceFile = Y.SourceFile$fromString(contents, $.$get$context().toUri$1(path));
      for (t1 = contents.length, i = 0; i < t1; ++i) {
        if (C.JSString_methods._codeUnitAt$1(contents, i) !== 65533)
          continue;
        throw H.wrapException(E.SassException$0("Invalid UTF-8.", Y.FileLocation$_(sourceFile, i).pointSpan$0()));
      }
      return contents;
    },
    _readFile0(path, encoding) {
      return B._systemErrorToFileSystemException0(new B._readFile_closure0(path, encoding));
    },
    fileExists0(path) {
      return B._systemErrorToFileSystemException0(new B.fileExists_closure0(path));
    },
    dirExists0(path) {
      return B._systemErrorToFileSystemException0(new B.dirExists_closure0(path));
    },
    listDir0(path) {
      return B._systemErrorToFileSystemException0(new B.listDir_closure0(false, path));
    },
    _systemErrorToFileSystemException0(callback) {
      var error, systemError, t1, exception, t2;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = type$.JsSystemError._as(error);
        t1 = systemError;
        t2 = J.getInterceptor$x(t1);
        throw H.wrapException(new B.FileSystemException0(J.substring$2$s(t2.get$message(t1), (H.S(t2.get$code(t1)) + ": ").length, J.get$length$asx(t2.get$message(t1)) - (", " + H.S(t2.get$syscall(t1)) + " '" + H.S(t2.get$path(t1)) + "'").length), J.get$path$x(systemError)));
      }
    },
    FileSystemException0: function FileSystemException0(t0, t1) {
      this.message = t0;
      this.path = t1;
    },
    Stderr0: function Stderr0(t0) {
      this._node1$_stderr = t0;
    },
    _readFile_closure0: function _readFile_closure0(t0, t1) {
      this.path = t0;
      this.encoding = t1;
    },
    fileExists_closure0: function fileExists_closure0(t0) {
      this.path = t0;
    },
    dirExists_closure0: function dirExists_closure0(t0) {
      this.path = t0;
    },
    listDir_closure0: function listDir_closure0(t0, t1) {
      this.recursive = t0;
      this.path = t1;
    },
    listDir__closure1: function listDir__closure1(t0) {
      this.path = t0;
    },
    listDir__closure2: function listDir__closure2() {
    },
    listDir_closure_list0: function listDir_closure_list0() {
    },
    listDir__list_closure0: function listDir__list_closure0(t0, t1) {
      this.parent = t0;
      this.list = t1;
    },
    ModifiableCssNode0: function ModifiableCssNode0() {
    },
    ModifiableCssParentNode0: function ModifiableCssParentNode0() {
    },
    _render(options, callback) {
      var fiber = J.get$fiber$x(options);
      if (fiber != null)
        J.run$0$x(fiber.call$1(P.allowInterop(new B._render_closure(callback, options))));
      else
        B._renderAsync(options).then$1$2$onError(0, new B._render_closure0(callback), new B._render_closure1(callback), type$.Null);
    },
    _renderAsync(options) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(type$.RenderResult),
        $async$returnValue, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, result, start, t1, data, file;
      var $async$_renderAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              start = new P.DateTime(Date.now(), false);
              t1 = J.getInterceptor$x(options);
              data = t1.get$data(options);
              file = X.NullableExtension_andThen0(t1.get$file(options), D.path__absolute$closure());
              $async$goto = data != null ? 3 : 5;
              break;
            case 3:
              // then
              t2 = B._parseImporter(options, start);
              t3 = B._parseFunctions(options, start, true);
              t4 = t1.get$indentedSyntax(options);
              t4 = !J.$eq$(t4, false) && t4 != null ? C.Syntax_Sass0 : null;
              t5 = B._parseOutputStyle(t1.get$outputStyle(options));
              t6 = J.$eq$(t1.get$indentType(options), "tab");
              t7 = B._parseIndentWidth(t1.get$indentWidth(options));
              t8 = B._parseLineFeed(t1.get$linefeed(options));
              t9 = file == null ? "stdin" : $.$get$context().toUri$1(file).toString$0(0);
              t10 = t1.get$quietDeps(options);
              if (t10 == null)
                t10 = false;
              t11 = t1.get$verbose(options);
              if (t11 == null)
                t11 = false;
              t1 = t1.get$charset(options);
              if (t1 == null)
                t1 = true;
              $async$goto = 6;
              return P._asyncAwait(X.compileStringAsync0(data, t1, t3, t7, t8, t2, t10, B._enableSourceMaps(options), t5, t4, t9, !t6, t11), $async$_renderAsync);
            case 6:
              // returning from await.
              result = $async$result;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = file != null ? 7 : 9;
              break;
            case 7:
              // then
              t2 = B._parseImporter(options, start);
              t3 = B._parseFunctions(options, start, true);
              t4 = t1.get$indentedSyntax(options);
              t4 = !J.$eq$(t4, false) && t4 != null ? C.Syntax_Sass0 : null;
              t5 = B._parseOutputStyle(t1.get$outputStyle(options));
              t6 = J.$eq$(t1.get$indentType(options), "tab");
              t7 = B._parseIndentWidth(t1.get$indentWidth(options));
              t8 = B._parseLineFeed(t1.get$linefeed(options));
              t9 = t1.get$quietDeps(options);
              if (t9 == null)
                t9 = false;
              t10 = t1.get$verbose(options);
              if (t10 == null)
                t10 = false;
              t1 = t1.get$charset(options);
              if (t1 == null)
                t1 = true;
              $async$goto = 10;
              return P._asyncAwait(X.compileAsync0(file, t1, t3, t7, t8, t2, t9, B._enableSourceMaps(options), t5, t4, !t6, t10), $async$_renderAsync);
            case 10:
              // returning from await.
              result = $async$result;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              throw H.wrapException(P.ArgumentError$(string$.Either, null));
            case 8:
              // join
            case 4:
              // join
              $async$returnValue = B._newRenderResult(options, result, start);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_renderAsync, $async$completer);
    },
    _renderSync(options) {
      var start, result, data, file, error, error0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, terseLogger, logger, stylesheet, result0, t13, exception, _null = null;
      try {
        start = new P.DateTime(Date.now(), false);
        result = null;
        t1 = J.getInterceptor$x(options);
        data = t1.get$data(options);
        file = X.NullableExtension_andThen0(t1.get$file(options), D.path__absolute$closure());
        if (data != null) {
          t2 = B._parseImporter(options, start);
          t3 = B._parseFunctions(options, start, false);
          t4 = t1.get$indentedSyntax(options);
          t4 = !J.$eq$(t4, false) && t4 != null ? C.Syntax_Sass0 : _null;
          t5 = B._parseOutputStyle(t1.get$outputStyle(options));
          t6 = J.$eq$(t1.get$indentType(options), "tab");
          t7 = B._parseIndentWidth(t1.get$indentWidth(options));
          t8 = B._parseLineFeed(t1.get$linefeed(options));
          t9 = file == null ? "stdin" : $.$get$context().toUri$1(file).toString$0(0);
          t10 = t1.get$quietDeps(options);
          if (t10 == null)
            t10 = false;
          t11 = t1.get$verbose(options);
          if (t11 == null)
            t11 = false;
          t1 = t1.get$charset(options);
          if (t1 == null)
            t1 = true;
          t12 = B._enableSourceMaps(options);
          if (!t11) {
            terseLogger = new Y.TerseLogger0(P.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.int), new S.StderrLogger0());
            logger = terseLogger;
          } else {
            terseLogger = _null;
            logger = terseLogger;
          }
          if (t4 == null)
            t4 = C.Syntax_SCSS0;
          stylesheet = V.Stylesheet_Stylesheet$parse0(data, t4, logger, t9);
          t4 = $.$get$context().absolute$7(".", _null, _null, _null, _null, _null, _null);
          result0 = U._compileStylesheet1(stylesheet, logger, _null, t2, new F.FilesystemImporter0(t4), new H.CastList(t3, H._arrayInstanceType(t3)._eval$1("CastList<1,Callable0>")), t5, !t6, t7, t8, t10, t12, t1);
          if (terseLogger != null)
            terseLogger.summarize$1$node(true);
          result = result0;
        } else if (file != null) {
          t2 = file;
          t3 = B._parseImporter(options, start);
          t4 = B._parseFunctions(options, start, false);
          t5 = t1.get$indentedSyntax(options);
          t5 = !J.$eq$(t5, false) && t5 != null ? C.Syntax_Sass0 : _null;
          t6 = B._parseOutputStyle(t1.get$outputStyle(options));
          t7 = J.$eq$(t1.get$indentType(options), "tab");
          t8 = B._parseIndentWidth(t1.get$indentWidth(options));
          t9 = B._parseLineFeed(t1.get$linefeed(options));
          t10 = t1.get$quietDeps(options);
          if (t10 == null)
            t10 = false;
          t11 = t1.get$verbose(options);
          if (t11 == null)
            t11 = false;
          t1 = t1.get$charset(options);
          if (t1 == null)
            t1 = true;
          t12 = B._enableSourceMaps(options);
          if (!t11) {
            terseLogger = new Y.TerseLogger0(P.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.int), new S.StderrLogger0());
            logger = terseLogger;
          } else {
            terseLogger = _null;
            logger = terseLogger;
          }
          t11 = B.readFile0(t2);
          if (t5 == null)
            t5 = M.Syntax_forPath0(t2);
          t13 = $.$get$context();
          stylesheet = V.Stylesheet_Stylesheet$parse0(t11, t5, logger, t13.toUri$1(t2));
          t2 = t13;
          result0 = U._compileStylesheet1(stylesheet, logger, _null, t3, new F.FilesystemImporter0(t2.absolute$7(".", _null, _null, _null, _null, _null, _null)), new H.CastList(t4, H._arrayInstanceType(t4)._eval$1("CastList<1,Callable0>")), t6, !t7, t8, t9, t10, t12, t1);
          if (terseLogger != null)
            terseLogger.summarize$1$node(true);
          result = result0;
        } else {
          t1 = P.ArgumentError$(string$.Either, _null);
          throw H.wrapException(t1);
        }
        t1 = B._newRenderResult(options, result, start);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassException0) {
          error = t1;
          t1 = B._wrapException(error);
          $.$get$_jsThrow().call$1(t1);
        } else {
          error0 = t1;
          t1 = B._newRenderError(J.toString$0$(error0), _null, _null, _null, 3);
          $.$get$_jsThrow().call$1(t1);
        }
      }
      throw H.wrapException("unreachable");
    },
    _wrapException(exception) {
      var file, t1, t2, t3,
        url = G.SourceSpanException.prototype.get$span.call(exception).file.url;
      if (url == null)
        file = "stdin";
      else
        file = url.get$scheme() === "file" ? $.$get$context().style.pathFromUri$1(M._parseUri(url)) : url.toString$0(0);
      t1 = C.JSString_methods.replaceFirst$2(exception.toString$0(0), "Error: ", "");
      t2 = G.SourceSpanException.prototype.get$span.call(exception);
      t2 = Y.FileLocation$_(t2.file, t2._file$_start);
      t2 = t2.file.getLine$1(t2.offset);
      t3 = G.SourceSpanException.prototype.get$span.call(exception);
      t3 = Y.FileLocation$_(t3.file, t3._file$_start);
      return B._newRenderError(t1, t3.file.getColumn$1(t3.offset) + 1, file, t2 + 1, 1);
    },
    _parseFunctions(options, start, asynch) {
      var result,
        functions = J.get$functions$x(options);
      if (functions == null)
        return C.List_empty19;
      result = H._setArrayType([], type$.JSArray_AsyncCallable_2);
      B.jsForEach(functions, new B._parseFunctions_closure(options, start, result, asynch));
      return result;
    },
    _parseImporter(options, start) {
      var importers, t2, t3, contextOptions, fiber,
        t1 = J.getInterceptor$x(options);
      if (t1.get$importer(options) == null)
        importers = H._setArrayType([], type$.JSArray_JSFunction);
      else {
        t2 = type$.List_nullable_Object;
        t3 = type$.JSFunction;
        importers = t2._is(t1.get$importer(options)) ? J.cast$1$0$ax(t2._as(t1.get$importer(options)), t3) : H._setArrayType([t3._as(t1.get$importer(options))], type$.JSArray_JSFunction);
      }
      t2 = J.getInterceptor$asx(importers);
      contextOptions = t2.get$isNotEmpty(importers) ? B._contextOptions(options, start) : new P.Object();
      fiber = t1.get$fiber(options);
      if (fiber != null) {
        t2 = t2.map$1$1(importers, new B._parseImporter_closure(fiber), type$.JSFunction);
        importers = P.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      t1 = t1.get$includePaths(options);
      if (t1 == null)
        t1 = [];
      t2 = type$.String;
      return new F.NodeImporter(contextOptions, P.List_List$unmodifiable(F.NodeImporter__addSassPath(P.List_List$from(t1, true, t2)), t2), P.List_List$unmodifiable(J.cast$1$0$ax(importers, type$.dynamic), type$.JSFunction));
    },
    _contextOptions(options, start) {
      var includePaths, t3, t4, t5, t6, t7,
        t1 = J.getInterceptor$x(options),
        t2 = t1.get$includePaths(options);
      if (t2 == null)
        t2 = [];
      includePaths = P.List_List$from(t2, true, type$.String);
      t2 = t1.get$file(options);
      t3 = t1.get$data(options);
      t4 = H._setArrayType([D.current()], type$.JSArray_String);
      C.JSArray_methods.addAll$1(t4, includePaths);
      t4 = C.JSArray_methods.join$1(t4, J.$eq$(J.get$platform$x(self.process), "win32") ? ";" : ":");
      t5 = J.$eq$(t1.get$indentType(options), "tab") ? 1 : 0;
      t6 = B._parseIndentWidth(t1.get$indentWidth(options));
      if (t6 == null)
        t6 = 2;
      t7 = B._parseLineFeed(t1.get$linefeed(options));
      t1 = t1.get$file(options);
      if (t1 == null)
        t1 = "data";
      return {file: t2, data: t3, includePaths: t4, precision: 10, style: 1, indentType: t5, indentWidth: t6, linefeed: t7.text, result: {stats: {start: start._core$_value, entry: t1}}};
    },
    _parseOutputStyle(style) {
      if (style == null || style === "expanded")
        return C.OutputStyle_expanded;
      if (style === "compressed")
        return C.OutputStyle_compressed0;
      throw H.wrapException(P.ArgumentError$('Unsupported output style "' + H.S(style) + '".', null));
    },
    _parseIndentWidth(width) {
      if (width == null)
        return null;
      return H._isInt(width) ? width : P.int_parse(J.toString$0$(width), null);
    },
    _parseLineFeed(str) {
      switch (str) {
        case "cr":
          return C.LineFeed_kMT;
        case "crlf":
          return C.LineFeed_Mss;
        case "lfcr":
          return C.LineFeed_a1Y;
        default:
          return C.LineFeed_D6m;
      }
    },
    _newRenderResult(options, result, start) {
      var t3, sourceMapOption, sourceMapPath, t4, sourceMapDir, outFile, t5, file, sourceMapDirUrl, i, source, t6, t7, sourceMapBytes, buffer, indices, url, t8, t9, _null = null,
        t1 = Date.now(),
        t2 = result._compile_result$_serialize,
        css = t2.css;
      if (B._enableSourceMaps(options)) {
        t3 = J.getInterceptor$x(options);
        sourceMapOption = t3.get$sourceMap(options);
        if (typeof sourceMapOption == "string")
          sourceMapPath = sourceMapOption;
        else {
          t4 = t3.get$outFile(options);
          t4.toString;
          sourceMapPath = J.$add$ansx(t4, ".map");
        }
        t4 = $.$get$context();
        sourceMapDir = t4.dirname$1(sourceMapPath);
        t2 = t2.sourceMap;
        t2.toString;
        t2.sourceRoot = t3.get$sourceMapRoot(options);
        outFile = t3.get$outFile(options);
        t5 = outFile == null;
        if (t5) {
          file = t3.get$file(options);
          if (file == null)
            t2.targetUrl = "stdin.css";
          else
            t2.targetUrl = t4.toUri$1(t4.withoutExtension$1(file) + ".css").toString$0(0);
        } else
          t2.targetUrl = t4.toUri$1(t4.relative$2$from(outFile, sourceMapDir)).toString$0(0);
        sourceMapDirUrl = t4.toUri$1(sourceMapDir).toString$0(0);
        for (t4 = t2.urls, i = 0; i < t4.length; ++i) {
          source = t4[i];
          if (source === "stdin")
            continue;
          t6 = $.$get$url();
          t7 = t6.style;
          if (t7.rootLength$1(source) <= 0 || t7.isRootRelative$1(source))
            continue;
          t4[i] = t6.relative$2$from(source, sourceMapDirUrl);
        }
        t4 = t3.get$sourceMapContents(options);
        sourceMapBytes = self.Buffer.from(C.C_JsonCodec.encode$2$toEncodable(t2.toJson$1$includeSourceContents(!J.$eq$(t4, false) && t4 != null), _null), "utf8");
        t2 = t3.get$omitSourceMapUrl(options);
        if (!(!J.$eq$(t2, false) && t2 != null)) {
          t2 = t3.get$sourceMapEmbed(options);
          if (!J.$eq$(t2, false) && t2 != null) {
            buffer = new P.StringBuffer("");
            indices = H._setArrayType([-1], type$.JSArray_int);
            P.UriData__writeUri("application/json", _null, _null, buffer, indices);
            indices.push(buffer._contents.length);
            t2 = buffer._contents += ";base64,";
            indices.push(t2.length - 1);
            t2 = C.C_Base64Encoder.startChunkedConversion$1(new P._StringSinkConversionSink(buffer));
            t3 = sourceMapBytes.length;
            P.RangeError_checkValidRange(0, t3, t3);
            t2._convert$_add$4(sourceMapBytes, 0, t3, true);
            t2 = buffer._contents;
            url = new P.UriData(t2.charCodeAt(0) == 0 ? t2 : t2, indices, _null).get$uri();
          } else {
            if (t5)
              t2 = sourceMapPath;
            else {
              t2 = $.$get$context();
              t2 = t2.relative$2$from(sourceMapPath, t2.dirname$1(outFile));
            }
            url = $.$get$context().toUri$1(t2);
          }
          css += "\n\n/*# sourceMappingURL=" + url.toString$0(0) + " */";
        }
      } else
        sourceMapBytes = _null;
      t2 = self.Buffer.from(css, "utf8");
      t3 = J.get$file$x(options);
      if (t3 == null)
        t3 = "data";
      t4 = start._core$_value;
      t1 = new P.DateTime(t1, false)._core$_value;
      t5 = C.JSInt_methods._tdivFast$1(P.Duration$(t1 - t4)._duration, 1000);
      t6 = H._setArrayType([], type$.JSArray_String);
      for (t7 = result._evaluate.loadedUrls, t7 = P._LinkedHashSetIterator$(t7, t7._collection$_modifications), t8 = H._instanceType(t7)._precomputed1; t7.moveNext$0();) {
        t9 = t8._as(t7._collection$_current);
        if (t9.get$scheme() === "file")
          t6.push($.$get$context().style.pathFromUri$1(M._parseUri(t9)));
        else
          t6.push(t9.toString$0(0));
      }
      return {css: t2, map: sourceMapBytes, stats: {entry: t3, start: t4, end: t1, duration: t5, includedFiles: t6}};
    },
    _enableSourceMaps(options) {
      var t2,
        t1 = J.getInterceptor$x(options);
      if (typeof t1.get$sourceMap(options) != "string") {
        t2 = t1.get$sourceMap(options);
        t1 = !J.$eq$(t2, false) && t2 != null && t1.get$outFile(options) != null;
      } else
        t1 = true;
      return t1;
    },
    _newRenderError(message, column, file, line, $status) {
      var error = new self.Error(message);
      error.formatted = "Error: " + message;
      if (line != null)
        error.line = line;
      if (column != null)
        error.column = column;
      if (file != null)
        error.file = file;
      error.status = $status;
      return error;
    },
    _render_closure: function _render_closure(t0, t1) {
      this.callback = t0;
      this.options = t1;
    },
    _render_closure0: function _render_closure0(t0) {
      this.callback = t0;
    },
    _render_closure1: function _render_closure1(t0) {
      this.callback = t0;
    },
    _parseFunctions_closure: function _parseFunctions_closure(t0, t1, t2, t3) {
      var _ = this;
      _.options = t0;
      _.start = t1;
      _.result = t2;
      _.asynch = t3;
    },
    _parseFunctions__closure: function _parseFunctions__closure(t0, t1, t2) {
      this.fiber = t0;
      this.callback = t1;
      this.context = t2;
    },
    _parseFunctions__