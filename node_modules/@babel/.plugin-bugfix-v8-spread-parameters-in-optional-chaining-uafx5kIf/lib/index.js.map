{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport type { NodePath } from \"@babel/traverse\";\nimport { types as t } from \"@babel/core\";\n// https://crbug.com/v8/11558\n\n// check if there is a spread element followed by another argument.\n// (...[], 0) or (...[], ...[])\n\nfunction matchAffectedArguments(argumentNodes) {\n  const spreadIndex = argumentNodes.findIndex(node => t.isSpreadElement(node));\n  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;\n}\n\n/**\n * Check whether the optional chain is affected by https://crbug.com/v8/11558.\n * This routine MUST not manipulate NodePath\n *\n * @export\n * @param {(NodePath<t.OptionalMemberExpression | t.OptionalCallExpression>)} path\n * @returns {boolean}\n */\nexport function shouldTransform(\n  path: NodePath<t.OptionalMemberExpression | t.OptionalCallExpression>,\n): boolean {\n  let optionalPath = path;\n  const chains = [];\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    chains.push(node);\n\n    if (optionalPath.isOptionalMemberExpression()) {\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n  for (let i = 0; i < chains.length; i++) {\n    const node = chains[i];\n    if (\n      t.isOptionalCallExpression(node) &&\n      matchAffectedArguments(node.arguments)\n    ) {\n      // f?.(...[], 0)\n      if (node.optional) {\n        return true;\n      }\n      // o?